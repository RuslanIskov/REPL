# -*- coding: UTF-8 -*-

import pickle

class RAliasesException(Exception):
	pass

class RAliases(object):
	def __init__(self, object=None, aliases=[]):
		self._aliases = {}
		self.add(object, aliases)
		
	@staticmethod
	def _getObjectName(object):
		name = getattr(object, '__name__', '' ) or getattr(object, '__class__' ).__name__
		return name
		
	@staticmethod
	def _aliasesHashableCheck(aliases):
		for alias in aliases:
			if not alias.__hash__:
				raise RAliasesException("non-hashable alias <{0}>".format(RAliases._getObjectName(alias)))

	def _aliasExists(self, alias):
		for object, aliases in self._aliases.items():
			if alias in aliases:
				return True
		return False
		
	def __getitem__(self, alias):
		'''повертає об'єкт з аліасом alias
		якщо аліасу немає — викидає RAliasesException
		'''
		for object in self._aliases:
			if alias in self._aliases[ object ]:
				return object
		raise RAliasesException
		
	def add(self, object, aliases):
		'''додає об'єкт з аліасами
		або додає аліаси до існуючого об'єкту
		'''
		if not object:
			return
		self._aliasesHashableCheck(aliases)
		for i in aliases: # не додавати дублікати
			if self._aliasExists(i):
				raise RAliasesException("alias <{0}> already exists".format(i))
		if not object in self._aliases: # новий об'єкт
			self._aliases[object] = []
		self._aliases[object].extend(aliases)
		return self._aliases[object] # вертаємо усі аліаси

	def get(self, alias, default=None):
		'''повертає об'єкт з аліасом alias
		якщо аліасу немає — повертає default
		'''
		for object in self._aliases:
			if alias in self._aliases[ object ]:
				return object
		return default
		
	def hasAlias(self, alias):
		return self._aliasExists(alias)
		
	def load(self):
		fh = open('./raliases.cfg', 'rb')
		self._aliases = pickle.load(fh)
		fh.close()
		
	def save(self):
		fh = open('./raliases.cfg', 'wb')
		pickle.dump(self._aliases, fh)
		fh.close()
		
